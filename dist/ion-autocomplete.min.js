/*
 * ion-autocomplete 0.3.0
 * Copyright 2015 Danny Povolotski
 * Copyright modifications 2015 Guy Brand
 * https://github.com/guylabs/ion-autocomplete
 */
!function () {
    "use strict";
    angular.module("ion-autocomplete", []).directive("ionAutocomplete", ["$ionicBackdrop", "$ionicScrollDelegate", "$document", "$q", "$parse", "$interpolate", "$ionicPlatform", "$compile", "$templateRequest", function (a, b, c, d, e, f, g, h, i) {
        return {
            require: ["ngModel", "ionAutocomplete"],
            restrict: "A",
            scope: {},
            bindToController: {
                ngModel: "=",
                templateData: "=",
                itemsMethod: "&",
                itemsClickedMethod: "&",
                itemsRemovedMethod: "&",
                modelToItemMethod: "&",
                searchItems: "=",
                selectedItems: "=",
                cancelButtonClickedMethod: "&"
            },
            controllerAs: "viewModel",
            controller: function (a) {
                var b = function (a, b) {
                    return a ? a : b
                };
                this.placeholder = b(a.placeholder, "Click to enter a value..."), this.cancelLabel = b(a.cancelLabel, "Done"), this.selectItemsLabel = b(a.selectItemsLabel, "Select an item..."), this.maxSelectedItems = b(a.maxSelectedItems, void 0), this.selectedItemsLabel = f(b(a.selectedItemsLabel, "Selected items{{maxSelectedItems ? ' (max. ' + maxSelectedItems + ')' : ''}}:"))(this), this.templateUrl = b(a.templateUrl, void 0), this.itemsMethodValueKey = b(a.itemsMethodValueKey, void 0), this.itemValueKey = b(a.itemValueKey, void 0), this.itemViewValueKey = b(a.itemViewValueKey, void 0), this.componentId = b(a.componentId, void 0), this.loadingIcon = b(a.loadingIcon, void 0), this.manageExternally = b(a.manageExternally, "false"), this.showLoadingIcon = !1, this.searchItems = b(this.searchItems, []), this.selectedItems = b(this.selectedItems, []), this.searchQuery = void 0
            },
            link: function (f, j, k, l) {
                var m = l[0], n = l[1], o = "ion-autocomplete-random-" + Math.floor(1e3 * Math.random() + 1), p = ['<div class="ion-autocomplete-container ' + o + ' modal" style="display: none;">', '<div class="bar bar-header item-input-inset">', '<label class="item-input-wrapper">', '<i class="icon ion-search placeholder-icon"></i>', '<input type="search" class="ion-autocomplete-search" ng-model="viewModel.searchQuery" placeholder="{{viewModel.placeholder}}"/>', "</label>", '<div class="ion-autocomplete-loading-icon" ng-if="viewModel.showLoadingIcon && viewModel.loadingIcon"><ion-spinner icon="{{viewModel.loadingIcon}}"></ion-spinner></div>', '<button class="ion-autocomplete-cancel button button-clear">{{viewModel.cancelLabel}}</button>', "</div>", '<ion-content class="has-header">', '<ion-item class="item-divider" ng-show="viewModel.selectedItems.length > 0">{{viewModel.selectedItemsLabel}}</ion-item>', '<ion-item ng-repeat="selectedItem in viewModel.selectedItems track by $index" class="item-icon-left item-icon-right">', '<i class="icon ion-checkmark"></i>', "{{viewModel.getItemValue(selectedItem, viewModel.itemViewValueKey)}}", '<i class="icon ion-trash-a" style="cursor:pointer" ng-click="viewModel.removeItem($index)"></i>', "</ion-item>", '<ion-item class="item-divider" ng-show="viewModel.searchItems.length > 0">{{viewModel.selectItemsLabel}}</ion-item>', '<ion-item collection-repeat="item in viewModel.searchItems" item-height="55px" item-width="100%" ng-click="viewModel.selectItem(item)">', "{{viewModel.getItemValue(item, viewModel.itemViewValueKey)}}", "</ion-item>", "</ion-content>", "</div>"].join("");
                n.templateUrl ? i(n.templateUrl).then(function (a) {
                    c.find("body").append(h(angular.element(a))(f))
                }) : c.find("body").append(h(angular.element(p))(f)), n.getItemValue = function (a, b) {
                    if (angular.isArray(a)) {
                        var c = [];
                        return angular.forEach(a, function (d) {
                            b && angular.isObject(a) ? c.push(e(b)(d)) : c.push(d)
                        }), c
                    }
                    return b && angular.isObject(a) ? e(b)(a) : a
                };
                var q = angular.element(c[0].querySelector("div.ion-autocomplete-container." + o + " input"));
                n.selectItem = function (a, b) {
                    b || (n.searchItems = [], n.searchQuery = void 0), n.maxSelectedItems != n.selectedItems.length && (w(n.selectedItems, n.itemValueKey, n.getItemValue(a, n.itemValueKey)) || (n.selectedItems = n.selectedItems.concat([a])), m.$setViewValue(n.selectedItems), m.$render(), 1 == n.maxSelectedItems && n.hideModal(), angular.isFunction(n.itemsClickedMethod) && n.itemsClickedMethod({
                        callback: {
                            item: a,
                            selectedItems: n.selectedItems.slice(),
                            componentId: n.componentId
                        }
                    }))
                }, n.removeItem = function (a) {
                    var b = n.selectedItems.splice(a, 1)[0];
                    n.selectedItems = n.selectedItems.slice(), m.$setViewValue(n.selectedItems), m.$render(), angular.isFunction(n.itemsRemovedMethod) && n.itemsRemovedMethod({
                        callback: {
                            item: b,
                            selectedItems: n.selectedItems.slice(),
                            componentId: n.componentId
                        }
                    })
                }, f.$watch("viewModel.searchQuery", function (a) {
                    if (void 0 !== a && ("" == a && (n.searchItems = []), angular.isFunction(n.itemsMethod))) {
                        n.showLoadingIcon = !0;
                        var c = {query: a};
                        n.componentId && (c = {query: a, componentId: n.componentId});
                        var e = d.when(n.itemsMethod(c));
                        e.then(function (a) {
                            a && a.data && (a = a.data), n.searchItems = n.getItemValue(a, n.itemsMethodValueKey), b.resize(), n.showLoadingIcon = !1
                        }, function (a) {
                            return d.reject(a)
                        })
                    }
                });
                var r = !1;
                n.showModal = function () {
                    r || (a.retain(), angular.element(c[0].querySelector("div.ion-autocomplete-container." + o)).css("display", "block"), f.$deregisterBackButton = g.registerBackButtonAction(function () {
                        n.hideModal()
                    }, 300), q.length > 0 && (q[0].focus(), setTimeout(function () {
                        q[0].focus()
                    }, 0)), b.resize(), r = !0)
                }, n.hideModal = function () {
                    angular.element(c[0].querySelector("div.ion-autocomplete-container." + o)).css("display", "none"), a.release(), f.$deregisterBackButton && f.$deregisterBackButton(), r = !1
                };
                var s = {moved: !1, startX: 0, startY: 0}, t = function (a) {
                    s.moved = !1, "undefined" != typeof a.originalEvent && (a = a.originalEvent), s.startX = a.touches[0].clientX, s.startY = a.touches[0].clientY
                }, u = function (a) {
                    "undefined" != typeof a.originalEvent && (a = a.originalEvent), (Math.abs(a.touches[0].clientX - s.startX) > 10 || Math.abs(a.touches[0].clientY - s.startY) > 10) && (s.moved = !0)
                }, v = function (a) {
                    s.moved || (a.preventDefault(), a.stopPropagation(), n.showModal())
                }, w = function (a, b, c) {
                    for (var d = 0; d < a.length; d++)if (n.getItemValue(a[d], b) === c)return !0;
                    return !1
                }, x = function (a, b) {
                    var c = d.when(n.modelToItemMethod({modelValue: a}));
                    c.then(function (a) {
                        n.selectItem(a, b)
                    }, function (a) {
                        return d.reject(a)
                    })
                };
                "false" == n.manageExternally && (j.bind("touchstart", t), j.bind("touchmove", u), j.bind("touchend click focus", v)), angular.element(c[0].querySelector("div.ion-autocomplete-container." + o + " button")).bind("click", function () {
                    n.searchQuery = void 0, n.hideModal(), angular.isFunction(n.cancelButtonClickedMethod) && n.cancelButtonClickedMethod({
                        callback: {
                            selectedItems: n.selectedItems.slice(),
                            componentId: n.componentId
                        }
                    })
                }), n.ngModel && angular.isFunction(n.modelToItemMethod) && (angular.isArray(n.ngModel) ? angular.forEach(n.ngModel, function (a) {
                    x(a, !0)
                }) : x(n.ngModel)), m.$render = function () {
                    j.val(n.getItemValue(m.$viewValue, n.itemViewValueKey))
                }, m.$formatters.push(function (a) {
                    var b = n.getItemValue(a, n.itemViewValueKey);
                    return void 0 == b ? "" : b
                }), m.$parsers.push(function (a) {
                    return n.getItemValue(a, n.itemValueKey)
                })
            }
        }
    }])
}();